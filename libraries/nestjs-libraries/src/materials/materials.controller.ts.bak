
import {
    Body,
    Controller,
    Get,
    Post,
    Query,
    Sse,
    MessageEvent,
    NotFoundException,
} from '@nestjs/common';
import { GetOrgFromRequest } from '@gitroom/nestjs-libraries/user/org.from.request';
import { Organization } from '@prisma/client';
import {
    MaterialsService,
    MaterialsSearchQuery,
} from '@gitroom/nestjs-libraries/materials/materials.service';
import { MaterialsQueueService } from '@gitroom/nestjs-libraries/materials/materials.queue.service';
import { MaterialsEventsService } from '@gitroom/nestjs-libraries/materials/materials.events.service';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { MediaCrawlerPlatform } from '@gitroom/nestjs-libraries/materials/materials.crawler.service';
import { z } from 'zod';
import { parseBody } from '@gitroom/helpers/utils/zod.utils';

export const searchSchema = z.object({
    platform: z.enum(['xhs', 'douyin', 'bilibili', 'weibo']),
    keywords: z.string().min(1),
    startPage: z.number().min(1).default(1),
    pageLimit: z.number().min(1).default(3),
    forceCrawl: z.boolean().optional(),
});

@Controller('materials')
export class MaterialsController {
    constructor(
        private readonly materialsService: MaterialsService,
        private readonly queueService: MaterialsQueueService,
        private readonly eventsService: MaterialsEventsService
    ) { }

    @Post('search')
    async search(
        @GetOrgFromRequest() org: Organization,
        @Body() body: z.infer<typeof searchSchema>
    ) {
        const params = await parseBody(searchSchema, body);
        const query: MaterialsSearchQuery = {
            orgId: org.id,
            platform: params.platform as MediaCrawlerPlatform,
            keywords: params.keywords,
            startPage: params.startPage,
            pageLimit: params.pageLimit,
        };

        const queryHash = this.materialsService.buildQueryHash(query);

        // 1. Check Cache (if not forced)
        if (!params.forceCrawl) {
            const cached = await this.materialsService.getCachedResult(query);
            if (cached) {
                return {
                    jobId: null,
                    state: 'completed',
                    cachedResults: cached,
                    cachedAt: cached.cachedAt,
                };
            }
        }

        // 2. Enqueue Job
        // Note: We don't have job duplication check here yet (except what BullMQ provides or custom logic)
        // For now, always create a new job if not cached.
        const job = await this.queueService.addSearchJob(org.id, params);

        return {
            jobId: job.id,
            state: await job.getState(),
            cachedResults: null,
        };
    }

    @Get('job-status')
    async getJobStatus(@Query('jobId') jobId: string) {
        const job = await this.queueService.getJob(jobId);
        if (!job) {
            throw new NotFoundException('Job not found');
        }
        const state = await job.getState();
        const progress = job.progress();

        // Check if it failed with specific reason
        const failedReason = job.failedReason;

        return {
            jobId,
            state,
            progress,
            failedReason,
            // If completed, we might want to return result summary here or let client fetch /results
        };
    }

    @Sse('events')
    events(@Query('jobId') jobId: string): Observable<MessageEvent> {
        return this.eventsService.subscribe(jobId).pipe(
            map((data) => ({
                data,
            }))
        );
    }
}
